\pretolerance=20000
\tolerance=30000
\setlength{\headheight}{14.61858pt}
\selectlanguage{spanish}
\pagestyle{fancy}

\chapter[Experimentaci\'on num\'erica]
{Experimentaci\'on num\'erica}
\label{ch:algorithms}

\vspace*{1cm}

\section{Algoritmos}
En esta secci\'on introduciremos a detalle nuestro algoritmo
para estimar la f\'ormula asint\'otica de Selberg del \cref{ch:selberg}.
Primero, realicemos ciertas manipulaciones a la f\'ormula demostrada
\[
  \frac{\sum_{p \leq x} \ln^2 p + \sum_{pq \leq x} \ln p \ln q - 2x\ln x}{x} = O(1).
\]

Por definici\'on, esto significa que existe
un momento \(n_0 > 0\)
y una constante \(c > 0\)
tales que
\[
  K(x)
  = \abs{\frac{\sum_{p \leq x} \ln^2 p
  + \sum_{pq \leq x} \ln p \ln q
  - 2x\ln x}{x}}
  \leq c
\]
para todo \(x \geq n_0\).
Convenientemente hemos definido \(K\)
para poder estimar asint\'oticamente la identidad de Selberg.

\begin{algorithm}[H]
    \SetAlgoLined
    \DontPrintSemicolon
    \Fn{\ObtenerPrimos{\(x\)}} {
        Sea \(M\brackets{0 \dots x}\) un nuevo arreglo est\'atico\;
        Inicializamos \(M\brackets{2 \dots x}\) con \textsc{Verdadero}\;
        \(M\brackets{0} = M\brackets{1} = \) \textsc{Falso}\;
        Sea \(P\) un nuevo arreglo din\'amico\;
        \For {\(n = 2\) \KwTo \(x\)} {
            \If {\(M\brackets{n}\)} {
                \textsc{Insert}\(\parentheses{P, n}\)\;
            }
            \For {\(p \in P\) and \(np \leq x\)} {
                \(M[np]\) = \textsc{Falso}\;
                \If {\(p \, \mid \, n\)} {
                    \textbf{break}\;
                }
            }
        }
        \KwRet{\(P\)}
    }
    \caption{Retorna un arreglo din\'amico con todos los n\'umeros primos menores o iguales a \(x\).}
\end{algorithm}

\begin{algorithm}[H]
    \SetAlgoLined
    \DontPrintSemicolon
    \Fn{\ObtenerMaximoPrimo{\(p, x, P\)}} {
        \(l = 0\)\;
        \(r = P.\,length - 1\)\;
        \If {\(p \cdot P\brackets{r} \leq x\)} {
            \KwRet{\(P\brackets{r}\)}
        }
        \If {\(p^2 > x\)} {
            \KwRet{\(-1\)}
        }
        \While {\(r - l > 1\)} {
            \(m = \floor{\parentheses{l + r} / 2}\)\;
            \eIf {\(p \cdot P\brackets{m} \leq x\)} {
                \(l = m\)\;
            }
            {
                \(r = m\)\;
            }
        }
        \KwRet{\(P\brackets{l}\)}
    }
    \caption{Retorna el m\'aximo primo \(q\) mayor o igual a \(p\) tal que \(pq \leq x\).}
\end{algorithm}

\begin{algorithm}[H]
    \SetAlgoLined
    \DontPrintSemicolon
    \Fn{\SumarUno{\(x, P\)}} {
        Sea \(L\brackets{0 \dots x}\) un nuevos arreglo est\'atico\;
        \(L\brackets{0} = 0\)\;
        \(s = 0\)\;
        \(i = 0\)\;
        \For {\(n = 1\) \KwTo \(x\)} {
            \If {\(i == P.\,length\)} {
                \textbf{break}\;
            }
            \(L\brackets{n} = L\brackets{n - 1}\)\;
            \If {\(P\brackets{i} == n\)} {
                \(L\brackets{n} = L\brackets{n} + \ln n\)\;
                \(s = s + \ln^2 n\)\;
                \(i = i + 1\)\;
            }
        }
        \KwRet{\(s\) y \(L\)}
    }
    \caption{Retorna \(\sum_{p \leq x} \ln^2 p\) y las sumas parciales de \(\sum_{p \leq x} \ln p\).}
\end{algorithm}

\begin{algorithm}[H]
    \SetAlgoLined
    \DontPrintSemicolon
    \Fn{\SumarDos{\(x, L, P\)}} {
        \(s = 0\)\;
        \For {\(p \in P\)} {
            \(q =\,\)\texttt{ObtenerM\'aximoPrimo}\(\parentheses{p, x, P}\)\;
            \If {\(q == -1\)} {
                \textbf{break}\;
            }
            \(s = s + \ln p \cdot \parentheses{L\brackets{q} - L\brackets{p - 1}}\)\;
        }
        \KwRet{\(s\)}
    }
    \caption{Retorna \(\sum_{pq \leq x} \ln p \ln q\).}
\end{algorithm}

\begin{algorithm}[H]
    \SetAlgoLined
    \DontPrintSemicolon
    \Fn{\K{\(x\)}} {
        \(P = \,\)\texttt{ObtenerPrimos}\((x)\)\;
        \(s \, , L = \,\)\texttt{Sumar}\(_1(x, P)\)\;
        \(t = \,\)\texttt{Sumar}\(_2(x, L, P)\)\;
        \KwRet{\(\abs{s + t - 2 x \ln x}/x\)}
    }
    \caption{Computa \(K(x)\)}
\end{algorithm}

\section{Estimados}

Realizamos nuestros experimentos en una
MacBook Pro \(15-\)inch \(2017\)
corriendo Ventura \(13.4\)
con \(16\)GB de RAM y
un CPU Quad-Core Intel Core i7
con m\'axima frecuencia de reloj de \(2.9\)GHz.
El procesador contiene \(4\) n\'ucleos
y cada n\'ucleo puede aprovechar \(2\) hilos
con hyper-threading technology habilitada.
Usamos el lenguaje de programaci\'on C++ para implementar los algoritmos,
utilizando el est\'andar C++17.
Los n\'umeros de \(64\) bits fueron emulados usando los tipos de datos
\texttt{long long} y \texttt{long double} del compilador
Apple clang version 14.0.3 (clang-1403.0.22.14.1).

\begin{table}[htbp]
    \centering
    \caption{Resultados y tiempos de computaci\'on en la MacBook Pro.}
    \begin{tabular}{cccc}
      \toprule
      \textbf{\(x\)} & \textbf{\(K(x)\)} & \textbf{Tiempo de computaci\'on (ms)} \\
      \midrule
      \(10^1\) & 4.6051701860 & 0 \\
      \(10^2\) & 9.2103403720 & 0 \\
      \(10^3\) & 13.8155105580 & 0 \\
      \(10^4\) & 18.4206807440 & 1 \\
      \(10^5\) & 23.0258509299 & 16 \\
      \(10^6\) & 27.6310211159 & 132 \\
      \(10^7\) & 32.2361913019 & 1333 \\
      \(10^8\) & 36.8413614879 & 14913 \\
      \bottomrule
    \end{tabular}
\end{table}
